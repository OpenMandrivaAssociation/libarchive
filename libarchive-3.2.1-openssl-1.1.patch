--- libarchive-3.2.1/libarchive/archive_cryptor.c.omv~	2016-09-16 02:06:16.024783558 +0200
+++ libarchive-3.2.1/libarchive/archive_cryptor.c	2016-09-16 02:10:39.740904126 +0200
@@ -302,6 +302,7 @@ aes_ctr_release(archive_crypto_ctx *ctx)
 static int
 aes_ctr_init(archive_crypto_ctx *ctx, const uint8_t *key, size_t key_len)
 {
+	ctx->ctx = EVP_CIPHER_CTX_new();
 
 	switch (key_len) {
 	case 16: ctx->type = EVP_aes_128_ecb(); break;
@@ -314,7 +315,7 @@ aes_ctr_init(archive_crypto_ctx *ctx, co
 	memcpy(ctx->key, key, key_len);
 	memset(ctx->nonce, 0, sizeof(ctx->nonce));
 	ctx->encr_pos = AES_BLOCK_SIZE;
-	EVP_CIPHER_CTX_init(&ctx->ctx);
+	EVP_CIPHER_CTX_init(ctx->ctx);
 	return 0;
 }
 
@@ -324,10 +325,10 @@ aes_ctr_encrypt_counter(archive_crypto_c
 	int outl = 0;
 	int r;
 
-	r = EVP_EncryptInit_ex(&ctx->ctx, ctx->type, NULL, ctx->key, NULL);
+	r = EVP_EncryptInit_ex(ctx->ctx, ctx->type, NULL, ctx->key, NULL);
 	if (r == 0)
 		return -1;
-	r = EVP_EncryptUpdate(&ctx->ctx, ctx->encr_buf, &outl, ctx->nonce,
+	r = EVP_EncryptUpdate(ctx->ctx, ctx->encr_buf, &outl, ctx->nonce,
 	    AES_BLOCK_SIZE);
 	if (r == 0 || outl != AES_BLOCK_SIZE)
 		return -1;
@@ -337,7 +338,7 @@ aes_ctr_encrypt_counter(archive_crypto_c
 static int
 aes_ctr_release(archive_crypto_ctx *ctx)
 {
-	EVP_CIPHER_CTX_cleanup(&ctx->ctx);
+	EVP_CIPHER_CTX_free(ctx->ctx);
 	memset(ctx->key, 0, ctx->key_len);
 	memset(ctx->nonce, 0, sizeof(ctx->nonce));
 	return 0;
--- libarchive-3.2.1/libarchive/archive_cryptor_private.h.omv~	2016-09-16 01:52:49.929610062 +0200
+++ libarchive-3.2.1/libarchive/archive_cryptor_private.h	2016-09-16 02:00:44.121409159 +0200
@@ -104,7 +104,7 @@ typedef struct {
 #define AES_MAX_KEY_SIZE 32
 
 typedef struct {
-	EVP_CIPHER_CTX	ctx;
+	EVP_CIPHER_CTX	*ctx;
 	const EVP_CIPHER *type;
 	uint8_t		key[AES_MAX_KEY_SIZE];
 	unsigned	key_len;
--- libarchive-3.2.1/libarchive/archive_hmac.c.omv~	2016-09-16 01:54:12.812700120 +0200
+++ libarchive-3.2.1/libarchive/archive_hmac.c	2016-09-16 02:05:10.481498751 +0200
@@ -176,8 +176,8 @@ __hmac_sha1_cleanup(archive_hmac_sha1_ct
 static int
 __hmac_sha1_init(archive_hmac_sha1_ctx *ctx, const uint8_t *key, size_t key_len)
 {
-	HMAC_CTX_init(ctx);
-	HMAC_Init(ctx, key, key_len, EVP_sha1());
+	*ctx = HMAC_CTX_new();
+	HMAC_Init_ex(*ctx, key, key_len, EVP_sha1(), NULL);
 	return 0;
 }
 
@@ -185,22 +185,21 @@ static void
 __hmac_sha1_update(archive_hmac_sha1_ctx *ctx, const uint8_t *data,
     size_t data_len)
 {
-	HMAC_Update(ctx, data, data_len);
+	HMAC_Update(*ctx, data, data_len);
 }
 
 static void
 __hmac_sha1_final(archive_hmac_sha1_ctx *ctx, uint8_t *out, size_t *out_len)
 {
 	unsigned int len = (unsigned int)*out_len;
-	HMAC_Final(ctx, out, &len);
+	HMAC_Final(*ctx, out, &len);
 	*out_len = len;
 }
 
 static void
 __hmac_sha1_cleanup(archive_hmac_sha1_ctx *ctx)
 {
-	HMAC_CTX_cleanup(ctx);
-	memset(ctx, 0, sizeof(*ctx));
+	HMAC_CTX_free(*ctx);
 }
 
 #else
--- libarchive-3.2.1/libarchive/archive_hmac_private.h.omv~	2016-09-16 02:00:13.632743264 +0200
+++ libarchive-3.2.1/libarchive/archive_hmac_private.h	2016-09-16 02:00:25.102617570 +0200
@@ -72,7 +72,7 @@ typedef	struct hmac_sha1_ctx archive_hma
 #elif defined(HAVE_LIBCRYPTO)
 #include <openssl/hmac.h>
 
-typedef	HMAC_CTX archive_hmac_sha1_ctx;
+typedef	HMAC_CTX* archive_hmac_sha1_ctx;
 
 #else
 
