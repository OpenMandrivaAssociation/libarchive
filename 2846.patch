diff -up libarchive-3.8.4/libarchive/archive.h.2~ libarchive-3.8.4/libarchive/archive.h
--- libarchive-3.8.4/libarchive/archive.h.2~	2025-12-01 13:42:06.000000000 +0100
+++ libarchive-3.8.4/libarchive/archive.h	2026-01-19 01:37:48.752713786 +0100
@@ -359,6 +359,7 @@ typedef const char *archive_passphrase_c
 #define	ARCHIVE_FORMAT_CPIO_SVR4_CRC		(ARCHIVE_FORMAT_CPIO | 5)
 #define	ARCHIVE_FORMAT_CPIO_AFIO_LARGE		(ARCHIVE_FORMAT_CPIO | 6)
 #define	ARCHIVE_FORMAT_CPIO_PWB			(ARCHIVE_FORMAT_CPIO | 7)
+#define	ARCHIVE_FORMAT_CPIO_STR			(ARCHIVE_FORMAT_CPIO | 8)
 #define	ARCHIVE_FORMAT_SHAR			0x20000
 #define	ARCHIVE_FORMAT_SHAR_BASE		(ARCHIVE_FORMAT_SHAR | 1)
 #define	ARCHIVE_FORMAT_SHAR_DUMP		(ARCHIVE_FORMAT_SHAR | 2)
diff -up libarchive-3.8.4/libarchive/archive_entry_link_resolver.c.2~ libarchive-3.8.4/libarchive/archive_entry_link_resolver.c
--- libarchive-3.8.4/libarchive/archive_entry_link_resolver.c.2~	2025-11-17 23:04:25.000000000 +0100
+++ libarchive-3.8.4/libarchive/archive_entry_link_resolver.c	2026-01-19 01:37:48.752946019 +0100
@@ -133,6 +133,7 @@ archive_entry_linkresolver_set_strategy(
 		switch (fmt) {
 		case ARCHIVE_FORMAT_CPIO_SVR4_NOCRC:
 		case ARCHIVE_FORMAT_CPIO_SVR4_CRC:
+		case ARCHIVE_FORMAT_CPIO_STR:
 			res->strategy = ARCHIVE_ENTRY_LINKIFY_LIKE_NEW_CPIO;
 			break;
 		default:
diff -up libarchive-3.8.4/libarchive/archive_private.h.2~ libarchive-3.8.4/libarchive/archive_private.h
--- libarchive-3.8.4/libarchive/archive_private.h.2~	2025-11-17 23:04:25.000000000 +0100
+++ libarchive-3.8.4/libarchive/archive_private.h	2026-01-19 01:37:48.750486723 +0100
@@ -93,6 +93,13 @@ struct archive_vtable {
 	const char * (*archive_filter_name)(struct archive *, int);
 };
 
+struct archive_private_metadata {
+	const char						*key;
+	void							*data;
+	void							(*free_fn)(void *);
+	struct archive_private_metadata *next;
+};
+
 struct archive_string_conv;
 
 struct archive {
diff -up libarchive-3.8.4/libarchive/archive_read.c.2~ libarchive-3.8.4/libarchive/archive_read.c
--- libarchive-3.8.4/libarchive/archive_read.c.2~	2025-11-17 23:04:25.000000000 +0100
+++ libarchive-3.8.4/libarchive/archive_read.c	2026-01-19 01:37:48.750766626 +0100
@@ -1065,6 +1065,7 @@ _archive_read_free(struct archive *_a)
 {
 	struct archive_read *a = (struct archive_read *)_a;
 	struct archive_read_passphrase *p;
+	struct archive_private_metadata *m;
 	int i, n;
 	int slots;
 	int r = ARCHIVE_OK;
@@ -1113,6 +1114,17 @@ _archive_read_free(struct archive *_a)
 		p = np;
 	}
 
+	/* Release private metadata. */
+	m = a->metadata;
+	while (m != NULL) {
+		struct archive_private_metadata *nm = m->next;
+
+		if (m->free_fn)
+			m->free_fn(m->data);
+		free(m);
+		m = nm;
+	}
+
 	archive_string_free(&a->archive.error_string);
 	archive_entry_free(a->entry);
 	a->archive.magic = 0;
@@ -1259,6 +1271,71 @@ __archive_read_register_bidder(struct ar
 	return (ARCHIVE_FATAL);
 }
 
+void *
+__archive_read_get_private(struct archive_read *a, const char *key)
+{
+	struct archive_private_metadata *m;
+
+	for (m = a->metadata; m != NULL; m = m->next) {
+		if (strcmp(m->key, key) == 0)
+			return m->data;
+	}
+
+	return NULL;
+}
+
+int
+__archive_read_set_private(struct archive_read *a,
+	const char *key,
+	void *data,
+	void (*free_fn)(void *))
+{
+	struct archive_private_metadata *m;
+
+	/* Replace if exists */
+	for (m = a->metadata; m != NULL; m = m->next) {
+		if (strcmp(m->key, key) == 0) {
+			if (m->free_fn)
+				m->free_fn(m->data);
+			m->data = data;
+			m->free_fn = free_fn;
+			return ARCHIVE_OK;
+		}
+	}
+
+	/* Insert new */
+	m = calloc(1, sizeof(*m));
+	if (!m)
+		return ARCHIVE_FATAL;
+
+	m->key = key;
+	m->data = data;
+	m->free_fn = free_fn;
+	m->next = a->metadata;
+	a->metadata = m;
+
+	return ARCHIVE_OK;
+}
+
+void
+__archive_read_clear_private(struct archive_read *a, const char *key)
+{
+	struct archive_private_metadata **pm = &a->metadata;
+	struct archive_private_metadata *m;
+
+	while ((m = *pm) != NULL) {
+		if (strcmp(m->key, key) == 0) {
+			*pm = m->next;
+			if (m->free_fn)
+				m->free_fn(m->data);
+			free(m);
+			return;
+		}
+
+		pm = &m->next;
+	}
+}
+
 /*
  * The next section implements the peek/consume internal I/O
  * system used by archive readers.  This system allows simple
diff -up libarchive-3.8.4/libarchive/archive_read_private.h.2~ libarchive-3.8.4/libarchive/archive_read_private.h
--- libarchive-3.8.4/libarchive/archive_read_private.h.2~	2025-11-17 23:04:25.000000000 +0100
+++ libarchive-3.8.4/libarchive/archive_read_private.h	2026-01-19 01:37:48.753444814 +0100
@@ -160,6 +160,8 @@ struct archive_read {
 
 	struct archive_entry	*entry;
 
+	struct archive_private_metadata	*metadata;
+
 	/* Dev/ino of the archive being read/written. */
 	int		  skip_file_set;
 	int64_t		  skip_file_dev;
@@ -244,6 +246,12 @@ int __archive_read_register_bidder(struc
 		const char *name,
 		const struct archive_read_filter_bidder_vtable *vtable);
 
+void *__archive_read_get_private(struct archive_read *, const char *);
+int __archive_read_set_private(struct archive_read *, const char *,
+		void *, void (*)(void *));
+void __archive_read_clear_private(struct archive_read *, const char *);
+
+
 const void *__archive_read_ahead(struct archive_read *, size_t, ssize_t *);
 const void *__archive_read_filter_ahead(struct archive_read_filter *,
     size_t, ssize_t *);
@@ -262,4 +270,36 @@ struct archive_read_extract *__archive_r
  */
 void __archive_read_reset_passphrase(struct archive_read *a);
 const char * __archive_read_next_passphrase(struct archive_read *a);
+
+struct rpm_file_info {
+	char		*pathname;
+	char		*uname;
+	char		*gname;
+	uint64_t	size;
+	uint16_t	mode;
+	int32_t		dev;
+	int16_t		rdev;
+	uint32_t	mtime;
+	uint32_t	ino;
+};
+
+struct rpm_inode_info {
+	uint64_t				n_files;
+	struct rpm_file_info	**files;
+	uint64_t				n_processed;
+};
+
+struct rpm_context {
+	/*
+	 * Testing revealed that the maximum ino matches the maximum fx.
+	 * When hardlinks are involved subsequent numbers appear to be simply skipped.
+	 */
+	union {
+		uint64_t	n_files;
+		uint64_t	n_inodes;
+	};
+	struct rpm_file_info	*files;		/* Indexed by fx. */
+	struct rpm_inode_info	*inodes;	/* Indexed by ino (-1). */
+};
+
 #endif
diff -up libarchive-3.8.4/libarchive/archive_read_support_filter_rpm.c.2~ libarchive-3.8.4/libarchive/archive_read_support_filter_rpm.c
--- libarchive-3.8.4/libarchive/archive_read_support_filter_rpm.c.2~	2025-11-17 23:04:25.000000000 +0100
+++ libarchive-3.8.4/libarchive/archive_read_support_filter_rpm.c	2026-01-19 01:37:48.751596685 +0100
@@ -37,6 +37,64 @@
 #include "archive_private.h"
 #include "archive_read_private.h"
 
+#define MAX_NFILES	100000
+#define STR_SIZE_LIMIT	(1024 * 1024) /* 1 MiB */
+
+#define RPM_LEAD_MAGIC		"\xed\xab\xee\xdb"
+#define RPM_HEADER_MAGIC	"\x8e\xad\xe8\x01\x00\x00\x00\x00"
+
+#define RPM_LEAD_SIZE		96
+#define RPM_MIN_HEAD_SIZE	16
+
+#define RPMTAG_FILESIZES		1028
+#define RPMTAG_FILEMODES		1030
+#define RPMTAG_FILERDEVS		1033
+#define RPMTAG_FILEMTIMES		1034
+#define RPMTAG_FILEUSERNAMES	1039
+#define RPMTAG_FILEGROUPNAMES	1040
+#define RPMTAG_FILEDEVICES      1095
+#define RPMTAG_FILEINODES		1096
+
+#define RPMTAG_DIRINDEXES	1116
+#define RPMTAG_BASENAMES	1117
+#define RPMTAG_DIRNAMES		1118
+
+#define RPMTAG_LONGFILESIZES	5008
+
+struct rpm_header_parse {
+	uint64_t	 n_files;
+
+	const char	 *basenames;
+	uint64_t	 n_basenames;
+
+	const char	 *dirnames;
+	uint64_t	 n_dirnames;
+
+	const char	 *usernames;
+	uint64_t	 n_usernames;
+
+	const char	 *groupnames;
+	uint64_t	 n_groupnames;
+
+	union {
+		const int64_t	*filesizes64;
+		const int32_t	*filesizes32;
+	};
+	uint8_t	is_filesizes64;
+
+	const int32_t	*dirindexes;
+	const int16_t	*filemodes;
+	const int32_t	*filedevices;
+	const int16_t	*filerdevs;
+	const int32_t	*filemtimes;
+	const int32_t	*fileinodes;
+};
+
+struct rpm_inode_map {
+	uint32_t	raw;
+	uint32_t	compact;
+};
+
 struct rpm {
 	int64_t		 total_in;
 	uint64_t	 hpos;
@@ -52,19 +110,37 @@ struct rpm {
 		ST_ARCHIVE	/* Reading 'Archive' section. */
 	}		 state;
 	int		 first_header;
+
+    unsigned char	*hbuf;
+    uint64_t		hbuf_size;
+    uint8_t			have_main_header;
 };
-#define RPM_LEAD_SIZE		96	/* Size of 'Lead' section. */
-#define RPM_MIN_HEAD_SIZE	16	/* Minimum size of 'Head'. */
 
 static int	rpm_bidder_bid(struct archive_read_filter_bidder *,
 		    struct archive_read_filter *);
 static int	rpm_bidder_init(struct archive_read_filter *);
 
-static ssize_t	rpm_filter_read(struct archive_read_filter *,
+static int64_t	rpm_filter_read(struct archive_read_filter *,
 		    const void **);
 static int	rpm_filter_close(struct archive_read_filter *);
 
-static inline size_t rpm_limit_bytes(uint64_t, size_t);
+static void	rpm_context_free(void *);
+
+static int	rpm_parse_main_header(struct archive_read *,
+			const unsigned char *, uint64_t);
+
+static uint16_t	rpm_be16_at(const void *buf_start,
+	const void *buf_end, const uint64_t off);
+static uint32_t	rpm_be32_at(const void *buf_start,
+	const void *buf_end, const uint64_t off);
+static uint64_t	rpm_be64_at(const void *buf_start,
+	const void *buf_end, const uint64_t off);
+
+static inline uint64_t	rpm_limit_bytes(uint64_t, uint64_t);
+static char	*rpm_safe_strndup(struct archive_read *, const char *);
+static void	rpm_strcat(struct archive_string *, const void *, const void *);
+static const char	*rpm_strlist_at(const char *, const void *,
+	uint64_t, uint64_t);
 
 #if ARCHIVE_VERSION_NUMBER < 4000000
 /* Deprecated; remove in libarchive 4.0 */
@@ -95,7 +171,7 @@ rpm_bidder_bid(struct archive_read_filte
     struct archive_read_filter *filter)
 {
 	const unsigned char *b;
-	ssize_t avail;
+	int64_t avail;
 	int bits_checked;
 
 	(void)self; /* UNUSED */
@@ -106,9 +182,9 @@ rpm_bidder_bid(struct archive_read_filte
 
 	bits_checked = 0;
 	/*
-	 * Verify Header Magic Bytes : 0XED 0XAB 0XEE 0XDB
+	 * Verify Header Magic Bytes
 	 */
-	if (memcmp(b, "\xED\xAB\xEE\xDB", 4) != 0)
+	if (memcmp(b, RPM_LEAD_MAGIC, sizeof(RPM_LEAD_MAGIC) - 1) != 0)
 		return (0);
 	bits_checked += 32;
 	/*
@@ -147,7 +223,7 @@ rpm_bidder_init(struct archive_read_filt
 	rpm = calloc(1, sizeof(*rpm));
 	if (rpm == NULL) {
 		archive_set_error(&self->archive->archive, ENOMEM,
-		    "Can't allocate data for rpm");
+		    "can't allocate data for rpm");
 		return (ARCHIVE_FATAL);
 	}
 
@@ -158,19 +234,13 @@ rpm_bidder_init(struct archive_read_filt
 	return (ARCHIVE_OK);
 }
 
-static inline size_t
-rpm_limit_bytes(uint64_t bytes, size_t max)
-{
-	return (bytes > max ? max : (size_t)bytes);
-}
-
-static ssize_t
+static int64_t
 rpm_filter_read(struct archive_read_filter *self, const void **buff)
 {
 	struct rpm *rpm;
 	const unsigned char *b;
-	ssize_t avail_in, total, used;
-	size_t n;
+	int64_t avail_in, total, used;
+	uint64_t n;
 	uint64_t section;
 	uint64_t bytes;
 
@@ -196,7 +266,7 @@ rpm_filter_read(struct archive_read_filt
 			if (rpm->total_in + avail_in < RPM_LEAD_SIZE)
 				used += avail_in;
 			else {
-				n = (size_t)(RPM_LEAD_SIZE - rpm->total_in);
+				n = (uint64_t)(RPM_LEAD_SIZE - rpm->total_in);
 				used += n;
 				b += n;
 				rpm->state = ST_HEADER;
@@ -208,16 +278,13 @@ rpm_filter_read(struct archive_read_filt
 		case ST_HEADER:
 			n = rpm_limit_bytes(RPM_MIN_HEAD_SIZE - rpm->hpos,
 			    avail_in - used);
-			memcpy(rpm->header+rpm->hpos, b, n);
+			memcpy(rpm->header + rpm->hpos, b, n);
 			b += n;
 			used += n;
 			rpm->hpos += n;
 
 			if (rpm->hpos == RPM_MIN_HEAD_SIZE) {
-				if (rpm->header[0] != 0x8e ||
-				    rpm->header[1] != 0xad ||
-				    rpm->header[2] != 0xe8 ||
-				    rpm->header[3] != 0x01) {
+				if (memcmp(rpm->header, RPM_HEADER_MAGIC, sizeof(RPM_HEADER_MAGIC) - 1) != 0) {
 					if (rpm->first_header) {
 						archive_set_error(
 						    &self->archive->archive,
@@ -230,26 +297,58 @@ rpm_filter_read(struct archive_read_filt
 					total = RPM_MIN_HEAD_SIZE;
 					break;
 				}
-				/* Calculate 'Header' length. */
-				section = archive_be32dec(rpm->header+8);
-				bytes = archive_be32dec(rpm->header+12);
-				rpm->hlen = rpm->hpos + section * 16 + bytes;
+
+				/* Calculate full header length. */
+				section = archive_be32dec(rpm->header + 8);
+				bytes = archive_be32dec(rpm->header + 12);
+				rpm->hlen = rpm->hpos + section * RPM_MIN_HEAD_SIZE + bytes;
 				rpm->state = ST_HEADER_DATA;
-				rpm->first_header = 0;
 			}
 			break;
-		case ST_HEADER_DATA:
-			n = rpm_limit_bytes(rpm->hlen - rpm->hpos,
-			    avail_in - used);
+		case ST_HEADER_DATA: {
+			uint64_t need = rpm->hlen - rpm->hpos;
+			n = rpm_limit_bytes(need, avail_in - used);
+
+			rpm->hbuf_size = rpm->hlen;
+			rpm->hbuf = realloc(rpm->hbuf, rpm->hbuf_size);
+			if (rpm->hbuf == NULL)
+				return ARCHIVE_FATAL;
+
+			/* Copy already-read 16-byte header record. */
+			memcpy(rpm->hbuf, rpm->header, RPM_MIN_HEAD_SIZE);
+
+			/* Append remaining header bytes at current hpos. */
+			memcpy(rpm->hbuf + rpm->hpos, b, n);
+
 			b += n;
 			used += n;
 			rpm->hpos += n;
-			if (rpm->hpos == rpm->hlen)
+
+			if (rpm->hpos == rpm->hlen) {
 				rpm->state = ST_PADDING;
+
+				/* Only parse the MAIN header (not the signature). */
+				if (!rpm->first_header && !rpm->have_main_header) {
+					const int r = rpm_parse_main_header(self->archive, rpm->hbuf, rpm->hbuf_size);
+					if (r != ARCHIVE_OK) {
+						total = r;
+						goto cleanup;
+					}
+
+					rpm->have_main_header = 1;
+				}
+			}
+
 			break;
+		}
 		case ST_PADDING:
 			while (used < avail_in) {
 				if (*b != 0) {
+					/* Finished one header; if that was the signature,
+					 * the next header is the main header. */
+					if (rpm->first_header && !rpm->have_main_header)
+						rpm->first_header = 0;
+
 					/* Read next header. */
 					rpm->state = ST_HEADER;
 					rpm->hpos = 0;
@@ -278,6 +377,12 @@ rpm_filter_read(struct archive_read_filt
 		rpm->total_in += used;
 		__archive_read_filter_consume(self->upstream, used);
 	}
+
+cleanup:
+	free(rpm->hbuf);
+	rpm->hbuf = NULL;
+	rpm->hbuf_size = 0;
+
 	return (total);
 }
 
@@ -292,3 +397,331 @@ rpm_filter_close(struct archive_read_fil
 	return (ARCHIVE_OK);
 }
 
+static void
+rpm_context_free(void *p)
+{
+	struct rpm_context *ctx = p;
+	uint64_t i;
+
+	if (ctx == NULL)
+		return;
+
+	if (ctx->inodes != NULL) {
+		for (i = 0; i < ctx->n_inodes; i++) {
+			free(ctx->inodes[i].files);
+		}
+
+		free(ctx->inodes);
+	}
+
+	if (ctx->files != NULL) {
+		for (i = 0; i < ctx->n_files; i++) {
+			free(ctx->files[i].pathname);
+			free(ctx->files[i].uname);
+			free(ctx->files[i].gname);
+		}
+
+		free(ctx->files);
+	}
+
+	free(ctx);
+}
+
+static int
+rpm_parse_main_header(struct archive_read *a,
+    const unsigned char *hbuf, uint64_t hlen)
+{
+	struct rpm_context *ctx;
+	struct rpm_header_parse hp;
+	struct rpm_inode_map *im;
+	const unsigned char *hbuf_end = hbuf + hlen;
+	uint64_t i, n_index, count;
+
+	memset(&hp, 0, sizeof(hp));
+
+	if (hlen < RPM_MIN_HEAD_SIZE)
+		return ARCHIVE_FATAL;
+
+	n_index = archive_be32dec(hbuf + 8);
+	count = archive_be32dec(hbuf + 12);
+
+	hbuf += RPM_MIN_HEAD_SIZE;
+	hlen -= RPM_MIN_HEAD_SIZE;
+
+	if ((uint64_t)n_index * RPM_MIN_HEAD_SIZE + count > hlen)
+		return ARCHIVE_FATAL;
+
+	for (i = 0; i < n_index; i++) {
+		uint32_t tag, /*type,*/ cnt;
+		int32_t off;
+		const unsigned char *p;
+		const unsigned char *ip = hbuf + i * RPM_MIN_HEAD_SIZE;
+
+		tag = rpm_be32_at(ip, hbuf_end, 0);
+		/*type = rpm_be32_at(ip, hbuf_end, 1);*/
+		off = rpm_be32_at(ip, hbuf_end, 2);
+		cnt = rpm_be32_at(ip, hbuf_end, 3);
+
+		if (off < 0 || (uint32_t)off >= count)
+			continue;
+
+		p = hbuf + (uint64_t)n_index * RPM_MIN_HEAD_SIZE + off;
+
+		switch (tag) {
+		case RPMTAG_BASENAMES:
+			hp.basenames = (const char *)p;
+			hp.n_basenames = cnt;
+			break;
+		case RPMTAG_DIRNAMES:
+			hp.dirnames = (const char *)p;
+			hp.n_dirnames = cnt;
+			break;
+		case RPMTAG_FILEUSERNAMES:
+			hp.usernames = (const char *)p;
+			hp.n_usernames = cnt;
+			break;
+		case RPMTAG_FILEGROUPNAMES:
+			hp.groupnames = (const char *)p;
+			hp.n_groupnames = cnt;
+			break;
+		case RPMTAG_LONGFILESIZES:
+			hp.filesizes64 = (const int64_t *)p;;
+			hp.n_files = cnt;
+			hp.is_filesizes64 = 1;
+			break;
+		case RPMTAG_FILESIZES:
+			/* This tag should never appear when Longfilesizes is present,
+			 * but checking doesn't hurt. */
+			if (!hp.is_filesizes64) {
+				hp.filesizes32 = (const int32_t *)p;
+				hp.n_files = cnt;
+			}
+			break;
+		case RPMTAG_DIRINDEXES:
+			hp.dirindexes = (const int32_t *)p;
+			break;
+		case RPMTAG_FILEINODES:
+			hp.fileinodes = (const int32_t *)p;
+			break;
+		case RPMTAG_FILEMODES:
+			hp.filemodes = (const int16_t *)p;
+			break;
+		case RPMTAG_FILEDEVICES:
+			hp.filedevices = (const int32_t *)p;
+			break;
+		case RPMTAG_FILERDEVS:
+			hp.filerdevs = (const int16_t *)p;
+			break;
+		case RPMTAG_FILEMTIMES:
+			hp.filemtimes = (const int32_t *)p;
+			break;
+		}
+	}
+
+	if (hp.n_files >= MAX_NFILES) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				"n_files out of range");
+		return (ARCHIVE_FATAL);
+	}
+
+	ctx = calloc(1, sizeof(*ctx));
+	if (ctx == NULL)
+		return (ARCHIVE_FATAL);
+
+	ctx->files = calloc(hp.n_files, sizeof(*ctx->files));
+	if (ctx->files == NULL)
+		goto fail;
+
+	ctx->n_files = hp.n_files;
+
+	for (i = 0; i < hp.n_files; i++) {
+		struct rpm_file_info *file = &ctx->files[i];
+		struct archive_string as;
+		const char *dname, *bname, *uname, *gname;
+
+		if (hp.dirindexes != NULL) {
+			const uint32_t diri = rpm_be32_at(hp.dirindexes, hbuf_end, i);
+
+			if (diri >= hp.n_dirnames) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+					"dirindex out of range");
+				goto fail;
+			}
+
+			dname = rpm_strlist_at(hp.dirnames, hbuf_end, diri, hp.n_dirnames);
+		} else
+			dname = NULL;
+
+		bname = rpm_strlist_at(hp.basenames, hbuf_end, i, hp.n_basenames);
+		uname = rpm_strlist_at(hp.usernames, hbuf_end, i, hp.n_usernames);
+		gname = rpm_strlist_at(hp.groupnames, hbuf_end, i, hp.n_groupnames);
+
+		archive_string_init(&as);
+		archive_strappend_char(&as, '.');
+		rpm_strcat(&as, dname, hbuf_end);
+		rpm_strcat(&as, bname, hbuf_end);
+		file->pathname = strdup(as.s);
+		archive_string_free(&as);
+
+		file->uname = rpm_safe_strndup(a, uname ? uname : "");
+		file->gname = rpm_safe_strndup(a, gname ? gname : "");
+
+		if (hp.is_filesizes64)
+			file->size = rpm_be64_at(hp.filesizes64, hbuf_end, i);
+		else
+			file->size = rpm_be32_at(hp.filesizes32, hbuf_end, i);
+		file->mode = rpm_be16_at(hp.filemodes, hbuf_end, i);
+		file->dev = rpm_be32_at(hp.filedevices, hbuf_end, i);
+		file->rdev = rpm_be16_at(hp.filerdevs, hbuf_end, i);
+		file->mtime = rpm_be32_at(hp.filemtimes, hbuf_end, i);
+		file->ino = rpm_be32_at(hp.fileinodes, hbuf_end, i);
+	}
+
+	ctx->inodes = calloc(hp.n_files, sizeof(*ctx->inodes));
+	if (ctx->inodes == NULL)
+		goto fail;
+
+	im = calloc(hp.n_files, sizeof(*im));
+	if (im == NULL)
+		goto fail;
+
+	count = 0;
+
+	/* Normalize inode numbers for indexing. */
+	for (i = 0; i < hp.n_files; i++) {
+		struct rpm_file_info *file = &ctx->files[i];
+		struct rpm_inode_info *inode;
+		const uint32_t raw = file->ino;
+		uint32_t j;
+
+		for (j = 0; j < count; j++) {
+			if (im[j].raw == raw)
+				break;
+		}
+
+		if (j == count) {
+			im[j].raw = raw;
+			im[j].compact = count;
+			count++;
+		}
+
+		inode = &ctx->inodes[im[j].compact];
+
+		inode->files = realloc(inode->files,
+			++inode->n_files * sizeof(struct rpm_file_info *));
+		inode->files[inode->n_files - 1] = file;
+
+		file->ino = im[j].compact;
+	}
+
+	free(im);
+
+	__archive_read_set_private(a, "rpm", ctx, rpm_context_free);
+
+	return (ARCHIVE_OK);
+fail:
+	rpm_context_free(ctx);
+	return (ARCHIVE_FATAL);
+}
+
+static uint16_t
+rpm_be16_at(const void *buf_start, const void *buf_end,
+	uint64_t off)
+{
+	off *= sizeof(uint16_t);
+
+	if (!buf_start || (buf_end <= buf_start) ||
+		(uint64_t)(buf_end - buf_start) < (off + sizeof(uint16_t)))
+		return 0;
+
+	return archive_be16dec(buf_start + off);
+}
+
+static uint32_t
+rpm_be32_at(const void *buf_start, const void *buf_end,
+	uint64_t off)
+{
+	off *= sizeof(uint32_t);
+
+	if (!buf_start || (buf_end <= buf_start) ||
+		(uint64_t)(buf_end - buf_start) < (off + sizeof(uint32_t)))
+		return 0;
+
+	return archive_be32dec(buf_start + off);
+}
+
+static uint64_t
+rpm_be64_at(const void *buf_start, const void *buf_end,
+	uint64_t off)
+{
+	off *= sizeof(uint64_t);
+
+	if (!buf_start || (buf_end <= buf_start) ||
+		(uint64_t)(buf_end - buf_start) < (off + sizeof(uint64_t)))
+		return 0;
+
+	return archive_be64dec(buf_start + off);
+}
+
+static inline uint64_t
+rpm_limit_bytes(const uint64_t bytes, const uint64_t max)
+{
+	return (bytes > max ? max : bytes);
+}
+
+static char *
+rpm_safe_strndup(struct archive_read *a, const char *s)
+{
+	uint64_t len;
+
+	if (s == NULL)
+		return NULL;
+
+	len = strnlen(s, STR_SIZE_LIMIT);
+	if (len == STR_SIZE_LIMIT) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+						  "malformed rpm header string");
+		return NULL;
+	}
+
+	return strndup(s, len);
+}
+
+static void
+rpm_strcat(struct archive_string *a, const void *s, const void *buf_end)
+{
+	if (!s || s >= buf_end)
+		return;
+
+	archive_strncat(a, s, rpm_limit_bytes(buf_end - s, STR_SIZE_LIMIT));
+}
+
+static const char *
+rpm_strlist_at(const char *p, const void *end,
+			   uint64_t i, uint64_t n)
+{
+	uint64_t k;
+
+	if (p == NULL || i >= n || (const char *)end < p)
+		return NULL;
+
+	for (k = 0; k < n; k++) {
+		uint64_t max_len = rpm_limit_bytes((const char *)end - p,
+										   STR_SIZE_LIMIT);
+
+		/* Unterminated or absurdly long string */
+		uint64_t len = strnlen(p, max_len);
+		if (len == max_len)
+			return NULL;
+
+		if (k == i)
+			return p;   /* <-- return BEFORE skipping */
+
+		p += len + 1;   /* move to next string */
+
+		if (p >= (const char *)end)
+			return NULL;
+	}
+
+	return NULL;
+}
diff -up libarchive-3.8.4/libarchive/archive_read_support_format_cpio.c.2~ libarchive-3.8.4/libarchive/archive_read_support_format_cpio.c
--- libarchive-3.8.4/libarchive/archive_read_support_format_cpio.c.2~	2025-11-17 23:04:25.000000000 +0100
+++ libarchive-3.8.4/libarchive/archive_read_support_format_cpio.c	2026-01-19 01:40:50.064368535 +0100
@@ -122,6 +122,16 @@
 #define	newc_header_size 110
 
 /*
+ * Stripped CPIO header, used by RPM.
+ * Only contains the magic and the file index.
+ */
+#define	str_magic_offset 0
+#define	str_magic_size 6
+#define	str_fx_offset 6
+#define	str_fx_size 8
+#define	str_header_size 16
+
+/*
  * An afio large ASCII header, which they named itself.
  * afio utility uses this header, if a file size is larger than 2G bytes
  * or inode/uid/gid is bigger than 65535(0xFFFF) or mtime is bigger than
@@ -174,7 +184,7 @@ struct links_entry {
 struct cpio {
 	int			  magic;
 	int			(*read_header)(struct archive_read *, struct cpio *,
-				     struct archive_entry *, size_t *, size_t *);
+				     struct archive_entry *);
 	struct links_entry	 *links_head;
 	int64_t			  entry_bytes_remaining;
 	int64_t			  entry_bytes_unconsumed;
@@ -204,20 +214,24 @@ static int64_t	be4(const unsigned char *
 static int	find_odc_header(struct archive_read *);
 static int	find_newc_header(struct archive_read *);
 static int	header_bin_be(struct archive_read *, struct cpio *,
-		    struct archive_entry *, size_t *, size_t *);
+		    struct archive_entry *);
 static int	header_bin_le(struct archive_read *, struct cpio *,
-		    struct archive_entry *, size_t *, size_t *);
+		    struct archive_entry *);
 static int	header_newc(struct archive_read *, struct cpio *,
-		    struct archive_entry *, size_t *, size_t *);
+		    struct archive_entry *);
 static int	header_odc(struct archive_read *, struct cpio *,
-		    struct archive_entry *, size_t *, size_t *);
+		    struct archive_entry *);
+static int	header_str(struct archive_read *, struct cpio *,
+		    struct archive_entry *);
 static int	header_afiol(struct archive_read *, struct cpio *,
-		    struct archive_entry *, size_t *, size_t *);
+		    struct archive_entry *);
 static int	is_octal(const char *, size_t);
 static int	is_hex(const char *, size_t);
 static int64_t	le4(const unsigned char *);
 static int	record_hardlink(struct archive_read *a,
 		    struct cpio *cpio, struct archive_entry *entry);
+static int	set_entry_pathname(struct archive_read *, struct archive_entry *,
+		    uint64_t, uint64_t);
 
 int
 archive_read_support_format_cpio(struct archive *_a)
@@ -303,6 +317,10 @@ archive_read_format_cpio_bid(struct arch
 		 * XXX TODO:  More verification; Could check that only hex
 		 * digits appear in appropriate header locations. XXX
 		 */
+	} else if (memcmp(p, "07070X", 6) == 0) {
+		/* Stripped cpio archive (RPM) */
+		cpio->read_header = header_str;
+		bid += 48;
 	} else if (p[0] * 256 + p[1] == 070707) {
 		/* big-endian binary cpio archives */
 		cpio->read_header = header_bin_be;
@@ -362,10 +380,8 @@ archive_read_format_cpio_read_header(str
     struct archive_entry *entry)
 {
 	struct cpio *cpio;
-	const void *h, *hl;
+	const void *hl;
 	struct archive_string_conv *sconv;
-	size_t namelength;
-	size_t name_pad;
 	int r;
 
 	cpio = (struct cpio *)(a->format->data);
@@ -379,32 +395,14 @@ archive_read_format_cpio_read_header(str
 		}
 		sconv = cpio->sconv_default;
 	}
-	
-	r = (cpio->read_header(a, cpio, entry, &namelength, &name_pad));
 
-	if (r < ARCHIVE_WARN)
+	r = (cpio->read_header(a, cpio, entry));
+
+	if (r < ARCHIVE_WARN || r == ARCHIVE_EOF)
 		return (r);
 
-	/* Read name from buffer. */
-	h = __archive_read_ahead(a, namelength + name_pad, NULL);
-	if (h == NULL)
-	    return (ARCHIVE_FATAL);
-	if (archive_entry_copy_pathname_l(entry,
-	    (const char *)h, namelength, sconv) != 0) {
-		if (errno == ENOMEM) {
-			archive_set_error(&a->archive, ENOMEM,
-			    "Can't allocate memory for Pathname");
-			return (ARCHIVE_FATAL);
-		}
-		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
-		    "Pathname can't be converted from %s to current locale.",
-		    archive_string_conversion_charset_name(sconv));
-		r = ARCHIVE_WARN;
-	}
 	cpio->entry_offset = 0;
 
-	__archive_read_consume(a, namelength + name_pad);
-
 	/* If this is a symlink, read the link contents. */
 	if (archive_entry_filetype(entry) == AE_IFLNK) {
 		if (cpio->entry_bytes_remaining > 1024 * 1024) {
@@ -439,14 +437,6 @@ archive_read_format_cpio_read_header(str
 	 * and parse it as a Solaris-style ACL, then read the next
 	 * header.  XXX */
 
-	/* Compare name to "TRAILER!!!" to test for end-of-archive. */
-	if (namelength == 11 && strncmp((const char *)h, "TRAILER!!!",
-	    10) == 0) {
-		/* TODO: Store file location of start of block. */
-		archive_clear_error(&a->archive);
-		return (ARCHIVE_EOF);
-	}
-
 	/* Detect and record hardlinks to previously-extracted entries. */
 	if (record_hardlink(a, cpio, entry) != ARCHIVE_OK) {
 		return (ARCHIVE_FATAL);
@@ -529,6 +519,19 @@ is_hex(const char *p, size_t len)
 	return (1);
 }
 
+static void
+fill_rpm_file_entry(struct archive_entry *entry, const struct rpm_file_info *file)
+{
+	archive_entry_set_pathname_utf8(entry, file->pathname);
+	archive_entry_set_uname_utf8(entry, file->uname);
+	archive_entry_set_gname_utf8(entry, file->gname);
+	archive_entry_set_dev(entry, file->dev);
+	archive_entry_set_ino(entry, file->ino);
+	archive_entry_set_mode(entry, file->mode);
+	archive_entry_set_rdev(entry, file->rdev);
+	archive_entry_set_mtime(entry, file->mtime, 0);
+}
+
 static int
 find_newc_header(struct archive_read *a)
 {
@@ -591,11 +594,13 @@ find_newc_header(struct archive_read *a)
 
 static int
 header_newc(struct archive_read *a, struct cpio *cpio,
-    struct archive_entry *entry, size_t *namelength, size_t *name_pad)
+	struct archive_entry *entry)
 {
+	struct rpm_context *ctx;
 	const void *h;
 	const char *header;
-	int r;
+	uint64_t name_len, name_pad;
+	int r, r2;
 
 	r = find_newc_header(a);
 	if (r < ARCHIVE_WARN)
@@ -611,36 +616,18 @@ header_newc(struct archive_read *a, stru
 
 	if (memcmp(header + newc_magic_offset, "070701", 6) == 0) {
 		a->archive.archive_format = ARCHIVE_FORMAT_CPIO_SVR4_NOCRC;
-		a->archive.archive_format_name = "ASCII cpio (SVR4 with no CRC)";
 	} else if (memcmp(header + newc_magic_offset, "070702", 6) == 0) {
 		a->archive.archive_format = ARCHIVE_FORMAT_CPIO_SVR4_CRC;
-		a->archive.archive_format_name = "ASCII cpio (SVR4 with CRC)";
 	} else {
 		/* TODO: Abort here? */
 	}
 
-	archive_entry_set_devmajor(entry,
-		(dev_t)atol16(header + newc_devmajor_offset, newc_devmajor_size));
-	archive_entry_set_devminor(entry, 
-		(dev_t)atol16(header + newc_devminor_offset, newc_devminor_size));
-	archive_entry_set_ino(entry, atol16(header + newc_ino_offset, newc_ino_size));
-	archive_entry_set_mode(entry, 
-		(mode_t)atol16(header + newc_mode_offset, newc_mode_size));
-	archive_entry_set_uid(entry, atol16(header + newc_uid_offset, newc_uid_size));
-	archive_entry_set_gid(entry, atol16(header + newc_gid_offset, newc_gid_size));
-	archive_entry_set_nlink(entry,
-		(unsigned int)atol16(header + newc_nlink_offset, newc_nlink_size));
-	archive_entry_set_rdevmajor(entry,
-		(dev_t)atol16(header + newc_rdevmajor_offset, newc_rdevmajor_size));
-	archive_entry_set_rdevminor(entry,
-		(dev_t)atol16(header + newc_rdevminor_offset, newc_rdevminor_size));
-	archive_entry_set_mtime(entry, atol16(header + newc_mtime_offset, newc_mtime_size), 0);
-	*namelength = (size_t)atol16(header + newc_namesize_offset, newc_namesize_size);
+	name_len = (size_t)atol16(header + newc_namesize_offset, newc_namesize_size);
 	/* Pad name to 2 more than a multiple of 4. */
-	*name_pad = (2 - *namelength) & 3;
+	name_pad = (2 - name_len) & 3;
 
 	/* Make sure that the padded name length fits into size_t. */
-	if (*name_pad > SIZE_MAX - *namelength) {
+	if (name_pad > UINT64_MAX - name_pad) {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 		    "cpio archive has invalid namelength");
 		return (ARCHIVE_FATAL);
@@ -652,12 +639,79 @@ header_newc(struct archive_read *a, stru
 	 * size.
 	 */
 	cpio->entry_bytes_remaining =
-	    atol16(header + newc_filesize_offset, newc_filesize_size);
-	archive_entry_set_size(entry, cpio->entry_bytes_remaining);
+		atol16(header + newc_filesize_offset, newc_filesize_size);
 	/* Pad file contents to a multiple of 4. */
 	cpio->entry_padding = 3 & -cpio->entry_bytes_remaining;
-	__archive_read_consume(a, newc_header_size);
-	return (r);
+	archive_entry_set_size(entry, cpio->entry_bytes_remaining);
+
+	ctx = __archive_read_get_private(a, "rpm");
+	if (ctx != NULL) {
+		struct rpm_file_info *file = NULL;
+		uint64_t i;
+
+		switch (a->archive.archive_format) {
+		case ARCHIVE_FORMAT_CPIO_SVR4_NOCRC:
+			a->archive.archive_format_name = "RPM cpio (SVR4 with no CRC)";
+			break;
+		case ARCHIVE_FORMAT_CPIO_SVR4_CRC:
+			a->archive.archive_format_name = "RPM cpio (SVR4 with CRC)";
+			break;
+		}
+
+		__archive_read_consume(a, newc_header_size);
+
+		r2 = set_entry_pathname(a, entry, name_len, name_pad);
+		if (r2 != ARCHIVE_OK)
+			return (r2);
+
+		for (i = 0; i < ctx->n_files; i++) {
+			file = &ctx->files[i];
+			if (strcmp(file->pathname, archive_entry_pathname(entry)) == 0) {
+				fill_rpm_file_entry(entry, file);
+				break;
+			}
+
+			file = NULL;
+		}
+
+		if (file == NULL) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				"rpm header has no such file");
+			return (ARCHIVE_FATAL);
+		}
+	} else {
+		switch (a->archive.archive_format) {
+		case ARCHIVE_FORMAT_CPIO_SVR4_NOCRC:
+			a->archive.archive_format_name = "ASCII cpio (SVR4 with no CRC)";
+			break;
+		case ARCHIVE_FORMAT_CPIO_SVR4_CRC:
+			a->archive.archive_format_name = "ASCII cpio (SVR4 with CRC)";
+			break;
+		}
+
+		archive_entry_set_devmajor(entry,
+			(dev_t)atol16(header + newc_devmajor_offset, newc_devmajor_size));
+		archive_entry_set_devminor(entry,
+			(dev_t)atol16(header + newc_devminor_offset, newc_devminor_size));
+		archive_entry_set_ino(entry, atol16(header + newc_ino_offset, newc_ino_size));
+		archive_entry_set_mode(entry,
+			(mode_t)atol16(header + newc_mode_offset, newc_mode_size));
+		archive_entry_set_uid(entry, atol16(header + newc_uid_offset, newc_uid_size));
+		archive_entry_set_gid(entry, atol16(header + newc_gid_offset, newc_gid_size));
+		archive_entry_set_nlink(entry,
+			(unsigned int)atol16(header + newc_nlink_offset, newc_nlink_size));
+		archive_entry_set_rdevmajor(entry,
+			(dev_t)atol16(header + newc_rdevmajor_offset, newc_rdevmajor_size));
+		archive_entry_set_rdevminor(entry,
+			(dev_t)atol16(header + newc_rdevminor_offset, newc_rdevminor_size));
+		archive_entry_set_mtime(entry, atol16(header + newc_mtime_offset, newc_mtime_size), 0);
+
+		__archive_read_consume(a, newc_header_size);
+
+		r2 = set_entry_pathname(a, entry, name_len, name_pad);
+	}
+
+	return (r2 == ARCHIVE_OK) ? (r) : (r2);
 }
 
 /*
@@ -766,11 +820,12 @@ find_odc_header(struct archive_read *a)
 
 static int
 header_odc(struct archive_read *a, struct cpio *cpio,
-    struct archive_entry *entry, size_t *namelength, size_t *name_pad)
+    struct archive_entry *entry)
 {
 	const void *h;
-	int r;
 	const char *header;
+	uint64_t name_len;
+	int r, r2;
 
 	a->archive.archive_format = ARCHIVE_FORMAT_CPIO_POSIX;
 	a->archive.archive_format_name = "POSIX octet-oriented cpio";
@@ -781,11 +836,8 @@ header_odc(struct archive_read *a, struc
 		return (r);
 
 	if (a->archive.archive_format == ARCHIVE_FORMAT_CPIO_AFIO_LARGE) {
-		int r2 = (header_afiol(a, cpio, entry, namelength, name_pad));
-		if (r2 == ARCHIVE_OK)
-			return (r);
-		else
-			return (r2);
+		r2 = (header_afiol(a, cpio, entry));
+		return r2 < r ? r2 : r;
 	}
 
 	/* Read fixed-size portion of header. */
@@ -808,8 +860,7 @@ header_odc(struct archive_read *a, struc
 	archive_entry_set_rdev(entry,
 		(dev_t)atol8(header + odc_rdev_offset, odc_rdev_size));
 	archive_entry_set_mtime(entry, atol8(header + odc_mtime_offset, odc_mtime_size), 0);
-	*namelength = (size_t)atol8(header + odc_namesize_offset, odc_namesize_size);
-	*name_pad = 0; /* No padding of filename. */
+	name_len = (size_t)atol8(header + odc_namesize_offset, odc_namesize_size);
 
 	/*
 	 * Note: entry_bytes_remaining is at least 64 bits and
@@ -821,7 +872,109 @@ header_odc(struct archive_read *a, struc
 	archive_entry_set_size(entry, cpio->entry_bytes_remaining);
 	cpio->entry_padding = 0;
 	__archive_read_consume(a, odc_header_size);
-	return (r);
+
+	r2 = set_entry_pathname(a, entry, name_len, 0);
+
+	return (r2 == ARCHIVE_OK) ? (r) : (r2);
+}
+
+static int
+find_str_header(struct archive_read *a)
+{
+	ssize_t avail;
+
+	for (;;) {
+		const unsigned char *p, *q, *end;
+
+		p = __archive_read_ahead(a, str_magic_size, &avail);
+		if (p == NULL) {
+			return (avail < 0 ? ARCHIVE_FATAL : ARCHIVE_EOF);
+		}
+
+		if (avail < (ssize_t)str_magic_size) {
+			/* Not enough bytes left for a full header. */
+			return ARCHIVE_EOF;
+		}
+
+		end = p + avail;
+
+		for (q = p; q + str_magic_size <= end; q++) {
+			if (memcmp(q, "07070X", str_magic_size) == 0) {
+				/* Consume up to the start of the header. */
+				__archive_read_consume(a, q - p);
+				return ARCHIVE_OK;
+			}
+		}
+
+		/* No match in this block: consume all but the last (str_magic_size - 1)
+		   bytes so we don't miss a header straddling the boundary. */
+		if (avail > (ssize_t)(str_magic_size - 1)) {
+			__archive_read_consume(a, avail - (str_magic_size - 1));
+		} else {
+			__archive_read_consume(a, avail);
+		}
+	}
+}
+
+static int
+header_str(struct archive_read *a, struct cpio *cpio,
+    struct archive_entry *entry)
+{
+	struct rpm_context *ctx;
+	struct rpm_file_info *file;
+	struct rpm_inode_info *inode;
+	const void *h;
+	const char *header;
+	uint32_t fx;
+	int r;
+
+	ctx = __archive_read_get_private(a, "rpm");
+	if (ctx == NULL) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, "no rpm context");
+		return (ARCHIVE_FATAL);
+	}
+
+	/* Find the start of the next header. */
+	r = find_str_header(a);
+	if (r != ARCHIVE_OK)
+		return (r);
+
+	/* Read fixed-size portion of header. */
+	h = __archive_read_ahead(a, str_header_size, NULL);
+	if (h == NULL)
+	    return (ARCHIVE_FATAL);
+
+	a->archive.archive_format = ARCHIVE_FORMAT_CPIO_STR;
+	a->archive.archive_format_name = "RPM cpio (stripped)";
+
+	/* Parse out hex fields. */
+	header = (const char *)h;
+
+	fx = strtoul(header + str_fx_offset, NULL, 16);
+	if (fx >= ctx->n_files) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, "fx out of range");
+		return (ARCHIVE_FATAL);
+	}
+
+	file = &ctx->files[fx];
+	inode = &ctx->inodes[file->ino];
+
+	fill_rpm_file_entry(entry, file);
+	archive_entry_set_nlink(entry, inode->n_files);
+
+	/* Eat stripped header */
+	__archive_read_consume(a, str_header_size);
+
+	/* Only the last hardlink group's entry carries the payload. */
+	if (++inode->n_processed == inode->n_files)
+		cpio->entry_bytes_remaining = file->size;
+	else
+		cpio->entry_bytes_remaining = 0;
+
+	archive_entry_set_size(entry, cpio->entry_bytes_remaining);
+	cpio->entry_padding = 0;
+
+	return ARCHIVE_OK;
 }
 
 /*
@@ -833,12 +986,12 @@ header_odc(struct archive_read *a, struc
  */
 static int
 header_afiol(struct archive_read *a, struct cpio *cpio,
-    struct archive_entry *entry, size_t *namelength, size_t *name_pad)
+    struct archive_entry *entry)
 {
-	int64_t t;
-	uint64_t u;
 	const void *h;
 	const char *header;
+	int64_t t;
+	uint64_t u, name_len;
 
 	a->archive.archive_format = ARCHIVE_FORMAT_CPIO_AFIO_LARGE;
 	a->archive.archive_format_name = "afio large ASCII";
@@ -868,8 +1021,7 @@ header_afiol(struct archive_read *a, str
 	archive_entry_set_rdev(entry,
 		(dev_t)atol16(header + afiol_rdev_offset, afiol_rdev_size));
 	archive_entry_set_mtime(entry, atol16(header + afiol_mtime_offset, afiol_mtime_size), 0);
-	*namelength = (size_t)atol16(header + afiol_namesize_offset, afiol_namesize_size);
-	*name_pad = 0; /* No padding of filename. */
+	name_len = (size_t)atol16(header + afiol_namesize_offset, afiol_namesize_size);
 
 	t = atol16(header + afiol_filesize_offset, afiol_filesize_size);
 	if (t < 0) {
@@ -880,16 +1032,18 @@ header_afiol(struct archive_read *a, str
 	archive_entry_set_size(entry, cpio->entry_bytes_remaining);
 	cpio->entry_padding = 0;
 	__archive_read_consume(a, afiol_header_size);
-	return (ARCHIVE_OK);
+
+	return set_entry_pathname(a, entry, name_len, 0);
 }
 
 
 static int
 header_bin_le(struct archive_read *a, struct cpio *cpio,
-    struct archive_entry *entry, size_t *namelength, size_t *name_pad)
+    struct archive_entry *entry)
 {
 	const void *h;
 	const unsigned char *header;
+	uint64_t name_len;
 
 	a->archive.archive_format = ARCHIVE_FORMAT_CPIO_BIN_LE;
 	a->archive.archive_format_name = "cpio (little-endian binary)";
@@ -919,22 +1073,23 @@ header_bin_le(struct archive_read *a, st
 	archive_entry_set_nlink(entry, header[bin_nlink_offset] + header[bin_nlink_offset + 1] * 256);
 	archive_entry_set_rdev(entry, header[bin_rdev_offset] + header[bin_rdev_offset + 1] * 256);
 	archive_entry_set_mtime(entry, le4(header + bin_mtime_offset), 0);
-	*namelength = header[bin_namesize_offset] + header[bin_namesize_offset + 1] * 256;
-	*name_pad = *namelength & 1; /* Pad to even. */
+	name_len = header[bin_namesize_offset] + header[bin_namesize_offset + 1] * 256;
 
 	cpio->entry_bytes_remaining = le4(header + bin_filesize_offset);
 	archive_entry_set_size(entry, cpio->entry_bytes_remaining);
 	cpio->entry_padding = cpio->entry_bytes_remaining & 1; /* Pad to even. */
 	__archive_read_consume(a, bin_header_size);
-	return (ARCHIVE_OK);
+
+	return set_entry_pathname(a, entry, name_len, name_len & 1);
 }
 
 static int
 header_bin_be(struct archive_read *a, struct cpio *cpio,
-    struct archive_entry *entry, size_t *namelength, size_t *name_pad)
+    struct archive_entry *entry)
 {
 	const void *h;
 	const unsigned char *header;
+	uint64_t name_len;
 
 	a->archive.archive_format = ARCHIVE_FORMAT_CPIO_BIN_BE;
 	a->archive.archive_format_name = "cpio (big-endian binary)";
@@ -964,14 +1119,14 @@ header_bin_be(struct archive_read *a, st
 	archive_entry_set_nlink(entry, header[bin_nlink_offset] * 256 + header[bin_nlink_offset + 1]);
 	archive_entry_set_rdev(entry, header[bin_rdev_offset] * 256 + header[bin_rdev_offset + 1]);
 	archive_entry_set_mtime(entry, be4(header + bin_mtime_offset), 0);
-	*namelength = header[bin_namesize_offset] * 256 + header[bin_namesize_offset + 1];
-	*name_pad = *namelength & 1; /* Pad to even. */
+	name_len = header[bin_namesize_offset] * 256 + header[bin_namesize_offset + 1];
 
 	cpio->entry_bytes_remaining = be4(header + bin_filesize_offset);
 	archive_entry_set_size(entry, cpio->entry_bytes_remaining);
 	cpio->entry_padding = cpio->entry_bytes_remaining & 1; /* Pad to even. */
 	    __archive_read_consume(a, bin_header_size);
-	return (ARCHIVE_OK);
+
+	return set_entry_pathname(a, entry, name_len, name_len & 1);
 }
 
 static int
@@ -1119,3 +1274,48 @@ record_hardlink(struct archive_read *a,
 
 	return (ARCHIVE_OK);
 }
+
+static int
+set_entry_pathname(struct archive_read *a, struct archive_entry *entry,
+    uint64_t namelength, uint64_t name_pad)
+{
+	struct cpio *cpio = a->format->data;
+	struct archive_string_conv *sconv;
+	int r = ARCHIVE_OK;
+
+	sconv = cpio->opt_sconv;
+	if (sconv == NULL) {
+		if (!cpio->init_default_conversion) {
+			cpio->sconv_default =
+			    archive_string_default_conversion_for_read(
+			      &(a->archive));
+			cpio->init_default_conversion = 1;
+		}
+		sconv = cpio->sconv_default;
+	}
+
+	/* Read name from buffer. */
+	const void *h = __archive_read_ahead(a, namelength + name_pad, NULL);
+	if (h == NULL)
+		return (ARCHIVE_FATAL);
+	if (archive_entry_copy_pathname_l(entry, (const char *)h, namelength, sconv)
+		!= 0) {
+		if (errno == ENOMEM) {
+			archive_set_error(&a->archive, ENOMEM,
+				"Can't allocate memory for Pathname");
+			return (ARCHIVE_FATAL);
+		}
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			"Pathname can't be converted from %s to current locale.",
+			archive_string_conversion_charset_name(sconv));
+		r = ARCHIVE_WARN;
+	}
+
+	__archive_read_consume(a, namelength + name_pad);
+
+	if (r == ARCHIVE_OK &&
+		strncmp(archive_entry_pathname(entry), "TRAILER!!!", 11) == 0)
+		r = ARCHIVE_EOF;
+
+	return (r);
+}
